
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Green Bee â€“ Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="layout.css">
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Dein firebase.initializeApp(...) hier einfÃ¼gen -->
  <script src="functions.js"></script>
</head>
<style>
  /* ADD THIS TO styles.css (or a <style> block) */
#summary-overlay{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.55);
  z-index: 80;
}

#summary-overlay .summary-panel{
  width: min(720px, 92vw);
  max-height: 80vh;
  overflow: auto;
}

.summary-grid{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 10px;
}

.summary-card{
  border: 1px solid var(--panel-border);
  background: var(--panel-bg);
  border-radius: 10px;
  padding: 10px;
}

.summary-card h3{
  font-size: 13px;
  margin: 0 0 6px 0;
}

.summary-table{
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}

.summary-table td{
  padding: 4px 0;
  vertical-align: top;
}

.summary-muted{
  opacity: 0.8;
  font-size: 12px;
  margin-top: 10px;
}
.budget-mini{
  margin: 8px 0 10px 0;
  padding: 8px 10px;
  border: 1px solid var(--panel-border);
  border-radius: 10px;
  background: var(--panel-bg);
  font-size: 13px;
  display: grid;
  gap: 6px;
}
.budget-mini > div{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
}
.budget-mini .muted{
  opacity: .8;
  font-weight: 600;
}

</style>
<body class="theme-light">
<!-- 1) ADD THIS DIRECTLY AFTER <body class="theme-light"> (or anywhere near the top of body) -->

  <!-- HEADER -->
  <header id="main-header">
    <div class="header-left">
      <img src="logo.png" class="logo-image" alt="GreenBee Logo" style="cursor:pointer"
     onclick="window.open('about.html', '_blank')">
    </div>

    <div class="header-center">
      <span id="world-display" class="header-pill">World: -</span>
      <span id="player-display" class="heade  r-pill">Player: -</span>
    </div>

    <div class="header-right">
      <!--<img src="firma-logo.png" class="company-logo" alt="Company Logo">
      <a href="impressum.html">Impressum</a>-->
      
      <button id="theme-toggle" class="btn small">â˜€ï¸Ž / ðŸŒ™</button>
    </div>
  </header>


  <!-- OVERLAY: WORLD + STUDENT SELECTION -->
  <div id="select-overlay">
    <div class="overlay-panel">
      <h2>Select World / Student</h2>

      <div class="field">
        <span>World</span>
        <select id="sel-world"></select>
      </div>

      <div class="field">
        <span>Student</span>
        <select id="sel-student"></select>
      </div>

      <button id="btn-confirm-student" class="btn primary">Continue</button>
      <p id="select-error" class="status"></p>
    </div>
  </div>


  <!-- OVERLAY: BUY / SELL -->
  <div id="buy-overlay">
    <div class="overlay-panel">
      <h2 id="buy-title">Field</h2>
      <div id="buy-content"></div>
      <button id="buy-close" class="btn small">Close</button>
    </div>
  </div>
<div id="summary-overlay">
  <div class="overlay-panel summary-panel">
    <h2>Event Summary</h2>
    <div id="summary-content"></div>
    <button id="summary-close" class="btn small">Close</button>
  </div>
</div>

  <!-- MAIN CONTENT -->
  <main class="page-wrap">

    <!-- OBERZEILE â€“ 70% -->
    <div class="row-grid">

      <!-- LEFT: Info Panel -->
      <section class="panel" id="panel-info">
        <h2>Marketing</h2>
          <div id="marketing-sliders" class="marketing-sliders"></div>

      </section>

      <!-- CENTER: SPIELFELD -->
      <section class="panel" id="panel-board">
        <svg id="game-board"></svg>
      </section>

      <!-- RIGHT: SHOP PANEL -->
      <section class="panel" id="panel-shop">
        <h2 id="turn-display">Info</h2>
<div id="shop-container">
  <div id="shop-hover-info" class="hover-info">    Hover over a tile or a chart to see details.
    <div id="budget-mini" class="budget-mini">
  <div><span class="muted">Current budget</span><span id="ui-current-budget">â‚¬0</span></div>
  <div><span class="muted">Income next turn</span><span id="ui-income-next">â‚¬0</span></div>
  <div><span class="muted">Projected next start</span><span id="ui-next-start">â‚¬0</span></div>
</div>

  </div>
  <div id="shop-dynamic"></div>
</div>
      </section>

    </div>


    <!-- UNTERE ZEILE â€“ 30% -->
    <div class="container-bottom">

      <section class="panel" id="panel-suitability">
        <h2>Suitability & Interest</h2>
        <svg id="suitability-chart"></svg>
      </section>

      <section class="panel" id="panel-budget">
        <h2>Budget</h2>
        <svg id="budget-chart"></svg>
      </section>

      <section class="panel" id="panel-tickets">
        <h2>Ticket Sales</h2>
        <svg id="ticket-chart"></svg>
      </section>

    </div>

  </main>


  <!-- FOOTER -->
  <footer id="main-footer">
    <button id="restart-btn" class="btn">Restart</button>
    <button id="nextturn-btn" class="btn primary">Next Turn</button>
  </footer>

  <script>
    // ===== Theme =====
    function applyThemeFromStorage() {
      const pref = localStorage.getItem("gb-theme") || "light";
      document.body.classList.toggle("theme-dark", pref === "dark");
    }
    document.getElementById("theme-toggle").addEventListener("click", () => {
      const isDark = document.body.classList.toggle("theme-dark");
      localStorage.setItem("gb-theme", isDark ? "dark" : "light");
    });
    applyThemeFromStorage();

    // ===== URL-Parameter =====
    function getUrlParams() {
      const p = new URLSearchParams(window.location.search);
      return {
        world: p.get("world") || "",
        player: p.get("player") || ""
      };
    }

const DEFAULT_DESCRIPTIONS = {
  bank: "A simple bench where visitors can rest. Seniors appreciate comfortable seating, and families value places to pause with children.",
  
  stand: "A basic information or sales stand. Attracts visitors moderately and provides a point of interaction or small purchases.",
  
  premium: "A high-quality stand offering better products or services. Strongly increases visitor interest, especially for young people and families.",
  
  bar: "A drinks bar that provides refreshments and social atmosphere. Youth and adults find it attractive; families benefit moderately.",
  
  animals: "A virtual-reality attraction offering an immersive experience. Very appealing to young visitors and tech-interested guests.",
  
  playground: "A playground area designed for children. Greatly increases interest for families and provides activity space.",
  
  stage: "A performance stage for music, shows or entertainment. Strongly increases interest, especially among young visitors.",
  
  empty: "Empty tile. You can build something here to make the area more attractive."
};

    const GROUP_COLORS = ["#22c55e", "#3b82f6", "#f97316"];
    //layout
const CHART_MARGIN = { top: 20, right: 20, bottom: 20, left: 5 };

const CHART_X_MIN = 0;
const CHART_X_MAX = 12;

const FONT_SIZE = "10px";
const FONT_FAMILY = "system-ui, sans-serif";

    // ===== Spielzustand =====
    let globalSettings = null;
    let worldSettings = null;
    let worldId = "";
    let playerId = "";
    let studentRecord = null;

    let gameState = null;
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

 function createEmptyGameState() {
  const startBudget = worldSettings.startBudget || 0;
  return {
    turn: 0,
    budget: startBudget,
    board: {},                 // { "A1":"shop", ... }
    budgetHistory: [startBudget],
    incomeHistory: [0],        // Einkommen pro Turn
    ticketSales: [0,0,0],   // drei Gruppen
    marketingBudgetHistory: [0],
  marketingPlan :{},// â‚¬ fÃ¼r nÃ¤chste Runde
interest : [0,0,0]// eventweit, aus Marketing kumuliert

  };
}


    function computeIncome() {
      const objs = globalSettings.objects || {};
      let income = 0;
      Object.values(gameState.board || {}).forEach(key => {
        const o = objs[key];
        if (o && o.income) income += o.income;
      });
      return income;
    }
function computeGlobalInterestFromMarketing() {
  const channels = (globalSettings && globalSettings.marketingChannels) || {};
  const plan = (gameState && gameState.marketingPlan) || {};

  const sum = [0, 0, 0];

  Object.keys(channels).forEach(key => {
    const ch = channels[key] || {};
    const maxSpend = Number(ch.maxSpend || 0);
    const spend = Number(plan[key] || 0);

    if (maxSpend <= 0 || spend <= 0) return;

    const p = Math.max(0, Math.min(1, spend / maxSpend));

    let eff = ch.effectiveness;
    // falls aus Firebase als Objekt "0","1","2" kommt
    if (eff && !Array.isArray(eff) && typeof eff === "object") {
      eff = [eff[0] ?? eff["0"] ?? 0, eff[1] ?? eff["1"] ?? 0, eff[2] ?? eff["2"] ?? 0];
    }
    if (!Array.isArray(eff)) eff = [0,0,0];

    sum[0] += p * (Number(eff[0]) || 0);
    sum[1] += p * (Number(eff[1]) || 0);
    sum[2] += p * (Number(eff[2]) || 0);
  });

  // optional: runden (damit es nicht â€œ0.3333333â€ wird)
  return sum.map(v => Math.round(v * 100) / 100);
}

    function computesuitability() {
      const objs = globalSettings.objects || {};
      const res = [0,0,0];
      Object.values(gameState.board || {}).forEach(key => {
        const o = objs[key];
        if (!o || !Array.isArray(o.suitability)) return;
        o.suitability.forEach((v,i) => {
          res[i] += (v||0);
        });
      });
      return res;
    }

    function calculateTicketsAfterTurn(suitabilityVec) {
      const totalAvailable = worldSettings.tickets || [0,0,0];
      const sold = gameState.ticketSales || [0,0,0];
      const remaining = totalAvailable.map((t,i) => Math.max(0, t - (sold[i]||0)));

      // einfache lineare Logik: Anteil suitability / (suitability + 50) * (remaining / (restliche Runden))
      const k = (globalSettings.baseRules && globalSettings.baseRules.suitabilitySaturationK) || 50;
      const turnsLeft = Math.max(1, (worldSettings.maxTurns || 10) - gameState.turn);
      const newSales = [0,0,0];

      suitabilityVec.forEach((ival, i) => {
        if (remaining[i] <= 0) return;
        const factor = ival <= 0 ? 0 : (ival / (ival + k));
        const base = remaining[i] / turnsLeft;
        const tickets = Math.min(remaining[i], Math.round(base * factor));
        newSales[i] = tickets;
      });

      gameState.ticketSales = sold.map((oldVal, i) => oldVal + (newSales[i] || 0));
    }

    // ===== UI Updates =====

function updateInfoPanel() {
  document.getElementById("turn-display").textContent = "Turn " + (gameState.turn || 0);

  const cur = Number(gameState.budget || 0);
  const incomeNext = Number(computeIncome() || 0);
  const nextStart = cur + incomeNext;

  const elCur = document.getElementById("ui-current-budget");
  const elInc = document.getElementById("ui-income-next");
  const elNext = document.getElementById("ui-next-start");

  if (elCur) elCur.textContent = `â‚¬${cur}`;
  if (elInc) elInc.textContent = `â‚¬${incomeNext}`;
  if (elNext) elNext.textContent = `â‚¬${nextStart}`;
}

function renderBoard() {
  const svg = d3.select("#game-board");
  svg.selectAll("*").remove();

  // Panel-MaÃŸe dynamisch bestimmen
  const panel = document.getElementById("panel-board");
  let width = panel.clientWidth;
  let height = panel.clientHeight;

  // Fallback, falls noch 0 (z.B. beim allerersten Render)
  if (!width || !height) {
    width = 600;
    height = 420;
  }

  // SVG so aufziehen, dass es mit diesen MaÃŸen arbeitet
  svg.attr("viewBox", `0 0 ${width} ${height}`);

  const gridSize = worldSettings.gridSize || 5;
  const objs = globalSettings.objects || {};
  const board = (gameState && gameState.board) ? gameState.board : {};
  const hexW = width / (gridSize );
  const hexH = hexW * 0.5;

  // Erst alle Zellen in "rohen" Koordinaten sammeln, dann zentrieren
  const cells = [];
  for (let row = 1; row <= gridSize; row++) {
    for (let col = gridSize - 1; col >= 0; col--) {
      const id = letters[col] + row;

      // Iso-Koordinaten relativ zu (0,0)
      const cx = (hexW * (0.5 * (col + row)));
      const cy = -(hexH * (0.5 * (col - row)));

      cells.push({ id, cx, cy });
    }
  }

  // Bounding Box der Zellen berechnen
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  cells.forEach(c => {
    if (c.cx < minX) minX = c.cx;
    if (c.cx > maxX) maxX = c.cx;
    if (c.cy < minY) minY = c.cy;
    if (c.cy > maxY) maxY = c.cy;
  });

  // Verschiebung, damit alles im Panel zentriert ist
  const centerGridX = (minX + maxX) / 2;
  const centerGridY = (minY + maxY) / 2;
  const offsetX = width / 2 - centerGridX;
  const offsetY = height / 2 - centerGridY;

  // Jetzt wirklich zeichnen
  cells.forEach(c => {
    const id = c.id;
    const cx = c.cx + offsetX;
    const cy = c.cy + offsetY;

    const objKey = board[id];
    const obj = objs[objKey] || {};
    const color = obj.color || "#9ca3af";

    const points = [
      [cx - hexW * 0.5, cy],
      [cx, cy + hexH * 0.5],
      [cx + hexW * 0.5, cy],
      [cx, cy - hexH * 0.5]
    ];

    const g = svg.append("g").attr("data-id", id);

const poly = g.append("polygon")
  .attr("points", points.map(p => p.join(",")).join(" "))
  .attr("fill", color)
  .attr("stroke", "#111827")
  .attr("stroke-width", 1)
  .on("click", () => onCellClicked(id))
  .on("mouseover", () => showTileInfo(id))
  .on("mouseout", () => clearTileInfo());

    if (obj.icon) {
      g.append("image")
        .attr("href", obj.icon)
        .attr("x", cx - hexW * 0.8)
        .attr("y", cy - hexH * 1.4)
        .attr("width", hexW * 1.6)
        .attr("height", hexH * 2.2)
        .on("mouseover", () => showTileInfo(id))
  .on("mouseout", () => clearTileInfo())

        .style("pointer-events", "none");
    }
  });
}

    function renderShop(selectedId, hasObject) {
  const overlayEl = document.getElementById("buy-overlay");
  const content = d3.select("#buy-content");
  const title = d3.select("#buy-title");
  const shopInfo = d3.select("#shop-dynamic");

  content.html("");
  shopInfo.html("");

  // Kein Feld ausgewÃ¤hlt -> Overlay aus, Hinweis im rechten Panel
  if (!selectedId) {
    overlayEl.style.display = "none";
    shopInfo.append("div").text("Click on a tile to build.");
    return;
  }

  // Header-Texte
  title.text("Field " + selectedId);
  shopInfo.append("div").text("Selected: " + selectedId);

  // Overlay anzeigen
  overlayEl.style.display = "flex";

  // Bereits bebautes Feld -> Sell-Option
  if (hasObject) {
    const objKey = gameState.board[selectedId];
    const obj = (globalSettings.objects || {})[objKey] || {};
    const sellPrice = Math.round((obj.price || 0) / 2);

    content.append("p").text(`You built: ${objKey}`);
    content.append("p").text(`Sell for â‚¬${sellPrice}?`);

    content.append("button")
      .attr("class", "btn primary small")
      .style("margin-top", "6px")
      .text(`Sell ${objKey}`)
      .on("click", async () => {
        gameState.budget += sellPrice;
        delete gameState.board[selectedId];


        overlayEl.style.display = "none";
        renderBoard();
        renderShop(null, false);
        updateAll();
        await saveGameState(worldId, playerId, gameState);
      });



  } else {
    // Leeres Feld -> Buy-Liste
    content.append("p").text("Choose an object to build:");

    const objs = globalSettings.objects || {};
    const enabled = worldSettings.objectsEnabled || {};

    Object.keys(objs).forEach(key => {
      if (!enabled[key]) return; // in dieser World deaktiviert

      const o = objs[key];

      content.append("button")
        .attr("class", "btn small")
        .style("margin", "4px 4px 0 0")
        .text(`${key} (â‚¬${o.price || 0})`)
        .on("click", async () => {
          const cost = o.price || 0;
          if (gameState.budget < cost) {
            alert("Not enough budget.");
            return;
          }

          gameState.budget -= cost;
          gameState.board[selectedId] = key;
          

          overlayEl.style.display = "none";
          renderBoard();
          renderShop(null, false);
          updateAll();
          await saveGameState(worldId, playerId, gameState);
        });
    });
  }
}

function onCellClicked(id) {
  const hasObject = !!gameState.board[id];
  renderShop(id, hasObject);
}

function rendersuitabilityChart() {
  const svg = d3.select("#suitability-chart");
  svg.selectAll("*").remove();

  const { width, height } = setupDynamicSvg(svg);

  const suitabilityRaw = computesuitability();           // [s1,s2,s3]
  const interest = (gameState.interest || [0,0,0]);      // [i1,i2,i3]
  const suitability = suitabilityRaw.map(v => (Number(v || 0) * 10));

  const groups = ["Youth", "Families", "Seniors"];

  const data = groups.map((g, i) => ({
    group: g,
    s: Number(suitability[i] || 0),
    i: Number(interest[i] || 0)
  }));

  const maxY = Math.max(
    1,
    d3.max(data, d => Math.max(d.s, d.i)) || 1
  );

  // Outer band = Gruppe
  const x0 = d3.scaleBand()
    .domain(groups)
    .range([CHART_MARGIN.left, width - CHART_MARGIN.right])
    .padding(0.35);

  // Inner band = {suitability, interest}
  const x1 = d3.scaleBand()
    .domain(["s", "i"])
    .range([0, x0.bandwidth()])
    .padding(0.25);

  const y = d3.scaleLinear()
    .domain([0, maxY])
    .range([height - CHART_MARGIN.bottom, CHART_MARGIN.top]);

  // Achsen ohne Labels (keine Text-Labels)
  const axX = svg.append("g")
    .attr("transform", `translate(0,${height - CHART_MARGIN.bottom})`)
    .call(d3.axisBottom(x0).tickFormat(""));

  const axY = svg.append("g")
    .attr("transform", `translate(${CHART_MARGIN.left},0)`)
    .call(d3.axisLeft(y).ticks(4).tickFormat(""));

  // optional: Tick-Linien ausblenden, wenn du komplett clean willst
  axX.selectAll("path, line").attr("stroke-opacity", 0.25);
  axY.selectAll("path, line").attr("stroke-opacity", 0.25);

  // Suitability Bars (volle Farbe)
  svg.append("g")
    .selectAll("rect.suit")
    .data(data)
    .enter()
    .append("rect")
    .attr("class", "suit")
    .attr("x", d => x0(d.group) + x1("s"))
    .attr("y", d => y(d.s))
    .attr("width", x1.bandwidth())
    .attr("height", d => Math.max(0, (y(0) - y(d.s))))
    .attr("fill", (d, i) => GROUP_COLORS[i])
    .attr("fill-opacity", 1.0);

  // Interest Bars (gleiche Farbe, transparenter)
  svg.append("g")
    .selectAll("rect.int")
    .data(data)
    .enter()
    .append("rect")
    .attr("class", "int")
    .attr("x", d => x0(d.group) + x1("i"))
    .attr("y", d => y(d.i))
    .attr("width", x1.bandwidth())
    .attr("height", d => Math.max(0, (y(0) - y(d.i))))
    .attr("fill", (d, i) => GROUP_COLORS[i])
    .attr("fill-opacity", 0.45);
}

function renderBudgetChart() {
  const svg = d3.select("#budget-chart");
  svg.selectAll("*").remove();

  const { width, height } = setupDynamicSvg(svg);

  // Budget-Verlauf
  const history = (gameState.budgetHistory || []).map((v, i) => ({
    turn: i,
    value: v
  }));

  // Einkommen pro Turn aus gameState.incomeHistory nehmen
  const rawIncome = gameState.incomeHistory || [];
  const incomeHistory = history.map((d, i) => ({
    turn: i,
    value: rawIncome[i] || 0
  }));

  const turnNow = gameState.turn || 0;

  const maxY = Math.max(
    1,
    d3.max(history, d => d.value),
    d3.max(incomeHistory, d => d.value)
  );

  const x = d3.scaleLinear()
    .domain([CHART_X_MIN, CHART_X_MAX])
    .range([CHART_MARGIN.left, width - CHART_MARGIN.right]);

  const y = d3.scaleLinear()
    .domain([0, maxY])
    .range([height - CHART_MARGIN.bottom, CHART_MARGIN.top]);

  const ticks = d3.range(CHART_X_MIN, CHART_X_MAX + 1);

  // â€¦ ab hier kann dein bisheriger Achsen- und Liniencode unverÃ¤ndert bleiben â€¦


  // Achsen
  svg.append("g")
    .attr("transform", `translate(0,${height - CHART_MARGIN.bottom})`)
    .call(d3.axisBottom(x).tickValues(ticks).tickFormat(d => "T" + d))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  svg.append("g")
    .attr("transform", `translate(${CHART_MARGIN.left},0)`)
    .call(d3.axisLeft(y).ticks(4))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  // Liniengenerator
  const line = d3.line()
    .x(d => x(d.turn))
    .y(d => y(d.value));

  // GRÃœNE LINIE: Budget
  svg.append("path")
    .datum(history)
    .attr("fill", "none")
    .attr("stroke", "#22c55e")
    .attr("stroke-width", 2)
    .attr("d", line);

  // BLAUE LINIE: Einnahmen pro Runde
  svg.append("path")
    .datum(incomeHistory)
    .attr("fill", "none")
    .attr("stroke", "#3b82f6")
    .attr("stroke-width", 2)
 //   .attr("stroke-dasharray", "4 2")
    .attr("d", line);

  // ROTE TURN-LINIE
  svg.append("line")
    .attr("x1", x(turnNow))
    .attr("x2", x(turnNow))
    .attr("y1", CHART_MARGIN.top)
    .attr("y2", height - CHART_MARGIN.bottom)
    .attr("stroke", "red")
    .attr("stroke-width", 2);
    //#endregion
    //#endregion

      // --- PROJECTION: from current turn -> next turn (dashed) ---
  const curTurn = turnNow;
  const nextTurn = curTurn + 1;

  if (nextTurn <= CHART_X_MAX) {
    const curBudget = Number(gameState.budget || 0);
    const incNext = Number(computeIncome() || 0);
    const nextStart = curBudget + incNext;

    // dashed line
    svg.append("line")
      .attr("x1", x(curTurn))
      .attr("y1", y(curBudget))
      .attr("x2", x(nextTurn))
      .attr("y2", y(nextStart))
      .attr("stroke", "#111827")
      .attr("stroke-width", 2)
      .attr("stroke-dasharray", "5 4")
      .attr("opacity", 0.65);

    // projected point
    svg.append("circle")
      .attr("cx", x(nextTurn))
      .attr("cy", y(nextStart))
      .attr("r", 4)
      .attr("fill", "#111827")
      .attr("opacity", 0.65);
  }

}

function renderTicketChart() {
  const svg = d3.select("#ticket-chart");
  svg.selectAll("*").remove();

  const { width, height } = setupDynamicSvg(svg);

  const totalAvailable = worldSettings.tickets || [0,0,0];
  const soldNow = gameState.ticketSales || [0,0,0];
  const suitability = computesuitability();
  const k = (globalSettings.baseRules?.suitabilitySaturationK) || 50;
  const turnNow = gameState.turn || 0;

  function simulateStep(current) {
    return current.map((v, i) => {
      const rem = totalAvailable[i] - v;
      if (rem <= 0) return v;
      const factor = suitability[i] / (suitability[i] + k);
      return v + Math.min(rem, Math.round(rem * factor * 0.25));
    });
  }

  const series = [];
  let sold = soldNow.slice();
  series.push({ t: turnNow, g0: sold[0], g1: sold[1], g2: sold[2] });

  for (let i = 1; i <= 3; i++) {
    sold = simulateStep(sold);
    series.push({ t: turnNow + i, g0: sold[0], g1: sold[1], g2: sold[2] });
  }

  const x = d3.scaleLinear()
    .domain([CHART_X_MIN, CHART_X_MAX])
    .range([CHART_MARGIN.left, width - CHART_MARGIN.right]);

  const maxY = d3.max(series, d => d.g0 + d.g1 + d.g2) || 1;

  const y = d3.scaleLinear()
    .domain([0, maxY])
    .range([height - CHART_MARGIN.bottom, CHART_MARGIN.top]);

  const stack = d3.stack().keys(["g0", "g1", "g2"]);
  const stacked = stack(series);

  const area = d3.area()
    .x(d => x(d.data.t))
    .y0(d => y(d[0]))
    .y1(d => y(d[1]));

  const colors = ["#22c55e", "#3b82f6", "#f97316"];

  stacked.forEach((layer, i) => {
    svg.append("path")
      .datum(layer)
      .attr("fill", colors[i])
      .attr("fill-opacity", 0.6)
      .attr("d", area);
  });

  const ticks = d3.range(CHART_X_MIN, CHART_X_MAX + 1);

  svg.append("g")
    .attr("transform", `translate(0,${height - CHART_MARGIN.bottom})`)
    .call(d3.axisBottom(x).tickValues(ticks).tickFormat(d => "T" + d))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  svg.append("g")
    .attr("transform", `translate(${CHART_MARGIN.left},0)`)
    .call(d3.axisLeft(y).ticks(4))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  svg.append("line")
    .attr("x1", x(turnNow))
    .attr("x2", x(turnNow))
    .attr("y1", CHART_MARGIN.top)
    .attr("y2", height - CHART_MARGIN.bottom)
    .attr("stroke", "red")
    .attr("stroke-width", 2);
}

function updateAll() {
  updateInfoPanel();
  rendersuitabilityChart();
  renderBudgetChart();
  renderTicketChart();
}



    document.getElementById("buy-close").addEventListener("click", () => {
  document.getElementById("buy-overlay").style.display = "none";
  d3.select("#shop-container").html("");
});
    // ===== Turn-Logik =====

async function nextTurn() {
  const income = computeIncome();

  const currentTurn = gameState.turn || 0;

  // Einkommen wirkt fÃ¼r die nÃ¤chste Runde
  const nextBudget = (gameState.budget || 0) + income;

  // turn -> next
  gameState.turn = currentTurn + 1;

  // History-Arrays sicherstellen
  if (!Array.isArray(gameState.budgetHistory)) gameState.budgetHistory = [];
  if (!Array.isArray(gameState.incomeHistory)) gameState.incomeHistory = [];

  // incomeHistory gehÃ¶rt zur gerade beendeten Runde (currentTurn)
  gameState.incomeHistory[currentTurn] = income;

  // budgetHistory ist immer Startbudget der jeweiligen Runde (NEUE Runde!)
  gameState.budgetHistory[gameState.turn] = nextBudget;

  // Budget wird zum Startbudget der neuen Runde
  gameState.budget = nextBudget;

  // Marketing -> Interest -> Tickets (werden beim Turnwechsel berechnet)
  gameState.interest = computeGlobalInterestFromMarketing();
  const suitability = computesuitability();
  calculateTicketsAfterTurn(suitability);

  updateAll();
  await saveGameState(worldId, playerId, gameState);

  const maxT = (worldSettings && worldSettings.maxTurns) || 10;
  if ((gameState.turn || 0) >= maxT) {
    showEventSummary();
  }
}

    async function restartGame() {
      if (!confirm("Restart game? This will reset your board.")) return;
      gameState = createEmptyGameState();
      renderBoard();
      renderShop(null,false);
      updateAll();
      resetHoverInfo();

      await saveGameState(worldId, playerId, gameState);
    }

    document.getElementById("nextturn-btn").addEventListener("click", () => {
      nextTurn();
    });
    document.getElementById("restart-btn").addEventListener("click", () => {
      restartGame();
    });

    // ===== Auswahl-Overlay =====

    async function showSelectionOverlay() {
      const overlay = document.getElementById("select-overlay");
      overlay.style.display = "flex";

      const worlds = await listWorlds();
      const selWorld = document.getElementById("sel-world");
      selWorld.innerHTML = "";
      worlds.forEach(w => {
        const opt = document.createElement("option");
        opt.value = w;
        opt.textContent = w;
        selWorld.appendChild(opt);
      });

      async function fillStudents() {
        const w = selWorld.value;
        const ws = await loadWorldSettings(w);
        const students = ws.students || {};
        const selStudent = document.getElementById("sel-student");
        selStudent.innerHTML = "";
        Object.keys(students).forEach(id => {
          const opt = document.createElement("option");
          opt.value = id;
          opt.textContent = students[id].name || id;
          selStudent.appendChild(opt);
        });
      }

      selWorld.addEventListener("change", fillStudents);
      await fillStudents();

      document.getElementById("btn-confirm-student").onclick = async () => {
        const w = selWorld.value;
        const s = document.getElementById("sel-student").value;
        const ws = await loadWorldSettings(w);
        const students = ws.students || {};
        const rec = students[s];
        if (!rec) {
          document.getElementById("select-error").textContent = "Student not found.";
          return;
        }
        const code = prompt("Enter your code:");
        if (code !== rec.code) {
          document.getElementById("select-error").textContent = "Wrong code.";
          return;
        }
        worldId = w;
        playerId = s;
        studentRecord = rec;
        overlay.style.display = "none";
        startGame();
      };
    }

    // ===== Start =====

    async function startGame() {
      document.getElementById("world-display").textContent = "World: " + worldId;
      document.getElementById("player-display").textContent = "Player: " + (studentRecord && studentRecord.name || playerId);

      globalSettings = await loadGlobalSettings();
      worldSettings = await loadWorldSettings(worldId);

    let existing = await loadGameState(worldId, playerId);
if (!existing) {
  existing = createEmptyGameState();
  await saveGameState(worldId, playerId, existing);
}
gameState = existing;
renderMarketingSliders();
// alte SpielstÃ¤nde reparieren, falls Felder fehlen
if (!gameState.board) {
  gameState.board = {};
}
if (!Array.isArray(gameState.budgetHistory)) {
  gameState.budgetHistory = [gameState.budget || 0];
}
if (!Array.isArray(gameState.ticketSales)) {
  gameState.ticketSales = [0, 0, 0];
}
if (!Array.isArray(gameState.incomeHistory)) {
  gameState.incomeHistory = [];
}

// aktuelles Einkommen fÃ¼r aktuellen Turn eintragen
const currentTurn = gameState.turn || 0;
const currentIncome = computeIncome();
gameState.incomeHistory[currentTurn] = currentIncome;



      renderBoard();
      renderShop(null,false);
      updateAll();
    }

    (async function init() {
      const params = getUrlParams();
      if (params.world && params.player) {
        // Direkt aus URL, trotzdem Code checken
        worldId = params.world;
        playerId = params.player;
        const ws = await loadWorldSettings(worldId);
        const students = ws.students || {};
        const rec = students[playerId];
        if (!rec) {
          await showSelectionOverlay();
        } else {
          const code = prompt("Enter your code:");
          if (code !== rec.code) {
            await showSelectionOverlay();
            return;
          }
          studentRecord = rec;
          await startGame();
        }
      } else {
        await showSelectionOverlay();
      }
    })();
// ===== Fenster-Resize ===== -> board rezise
    window.addEventListener("resize", () => {
  if (gameState) renderBoard();
});


function setupDynamicSvg(svg) {
  const node = svg.node();
  const parent = node.parentElement;

  const w = parent.clientWidth;
  const h = parent.clientHeight;

  // Falls beim ersten Render 0x0 â†’ Notfallwerte
  const width = Math.max(w, 200);
  const height = Math.max(h, 120);

  svg.attr("viewBox", `0 0 ${width} ${height}`);

  return { width, height };
}
function showTileInfo(id) {
  const board = (gameState && gameState.board) ? gameState.board : {};
  const objs = globalSettings.objects || {};
  const objKey = board[id];

  if (objKey && objs[objKey]) {
    const o = objs[objKey];

    const desc =
      o.descriptionEn ||
      DEFAULT_DESCRIPTIONS[objKey] ||
      "This object has no description yet.";

    const price = (o.price ?? 0);
    const income = (o.income ?? 0);
    const suit = Array.isArray(o.suitability) ? o.suitability : [0,0,0];

    setHoverInfo(
`Board â€“ Tile ${id}
Object: ${objKey}

${desc}

Cost: â‚¬${price}
Income/turn: â‚¬${income}
Suitability (G1/G2/G3): ${suit[0]||0} / ${suit[1]||0} / ${suit[2]||0}`
    );
  } else {
    setHoverInfo(
`Board â€“ Tile ${id}
Empty tile.

${DEFAULT_DESCRIPTIONS.empty || "You can build something here."}`
    );
  }
}

function clearTileInfo() {
  resetHoverInfo();
}


function setHoverInfo(text) {
  const el = document.getElementById("hover-text");
  if (!el) return;
  el.textContent = text || "";
}


function resetHoverInfo() {
  setHoverInfo("Hover over a tile or a chart to see details.");
}

function showBudgetInfo() {
  const turn = gameState.turn || 0;

  const startBudget = Array.isArray(gameState.budgetHistory)
    ? (gameState.budgetHistory[turn] ?? gameState.budgetHistory[gameState.budgetHistory.length - 1] ?? 0)
    : 0;

  const currentBudget = Number(gameState.budget || 0);
  const spentThisTurn = Math.max(0, Number(startBudget) - Number(currentBudget));

  const incomeNext = Number(computeIncome() || 0);
  const projectedNextStart = currentBudget + incomeNext;

  setHoverInfo(
`Budget Panel
Turn: ${turn}

Start budget (this turn): â‚¬${startBudget}
Current budget (after purchases): â‚¬${currentBudget}
Spent this turn (purchases): â‚¬${spentThisTurn}

Income (applies next turn): â‚¬${incomeNext}
Projected next start budget: â‚¬${projectedNextStart}`
  );
}

const budgetPanel = document.getElementById("panel-budget");
budgetPanel.addEventListener("mouseenter", showBudgetInfo);
budgetPanel.addEventListener("mouseleave", resetHoverInfo);

function computeInterest() {
  return gameState.interest || [0,0,0];
}

function showSuitabilityPanelInfo() {
  const interest = computeInterest();
  const suitability = computesuitability();

  setHoverInfo(
`Suitability Panel

Interest (G1/G2/G3): ${interest[0]||0} / ${interest[1]||0} / ${interest[2]||0}
Suitability (G1/G2/G3): ${suitability[0]||0} / ${suitability[1]||0} / ${suitability[2]||0}`
  );
}

const suitPanel = document.getElementById("panel-suitability");
suitPanel.addEventListener("mouseenter", showSuitabilityPanelInfo);
suitPanel.addEventListener("mouseleave", resetHoverInfo);
function renderMarketingSliders() {
  const host = document.getElementById("marketing-sliders");
  if (!host) return;

  // âœ… richtiger Key aus Firebase
  const channels = (globalSettings && globalSettings.marketingChannels) || {};

  host.innerHTML = "";

  // Plan sicherstellen
  if (!gameState.marketingPlan) gameState.marketingPlan = {};

  // Falls keine Channels gefunden: kleine Debug-Ausgabe im UI (damit man es sieht)
  const keys = Object.keys(channels);
  if (keys.length === 0) {
    host.innerHTML = "<div style='font-size:12px;opacity:.8'>No marketingChannels found in globalsettings.</div>";
    return;
  }

  keys.forEach(key => {
    const ch = channels[key] || {};

    const label = ch.label || key;

    const maxSpend = Math.max(0, Number(ch.maxSpend || 0));

    // Firebase kann arrays als Objekt "0":30 "1":30 "2":40 speichern -> normalisieren
    let eff = ch.effectiveness;
    if (eff && !Array.isArray(eff) && typeof eff === "object") {
      eff = [eff[0] ?? eff["0"] ?? 0, eff[1] ?? eff["1"] ?? 0, eff[2] ?? eff["2"] ?? 0].map(v => Number(v || 0));
    } else if (!Array.isArray(eff)) {
      eff = [0, 0, 0];
    }

    if (typeof gameState.marketingPlan[key] !== "number") gameState.marketingPlan[key] = 0;

    // clamp
    if (gameState.marketingPlan[key] > maxSpend) gameState.marketingPlan[key] = maxSpend;

    const row = document.createElement("div");
    row.className = "mkt-row";

    const left = document.createElement("div");
    left.className = "mkt-slider-wrap";

    const lab = document.createElement("div");
    lab.className = "mkt-label";
    lab.textContent = label;

    const meta = document.createElement("div");
   
    const slider = document.createElement("input");
    slider.className = "mkt-slider";
    slider.type = "range";
    slider.min = "0";
    slider.max = String(maxSpend);
    slider.step = "1";
    slider.value = String(gameState.marketingPlan[key] || 0);

    const right = document.createElement("div");
    right.className = "mkt-value";
    right.textContent = `â‚¬${slider.value}`;

    slider.addEventListener("input", () => {
      const v = parseInt(slider.value, 10) || 0;
      gameState.marketingPlan[key] = v;
      right.textContent = `â‚¬${v}`;
    });

    left.appendChild(lab);
    left.appendChild(meta);
    left.appendChild(slider);

    row.appendChild(left);
    row.appendChild(right);
    host.appendChild(row);
  });
}


function isGameFinished() {
  const maxT = (worldSettings && worldSettings.maxTurns) || 10;
  return (gameState && (gameState.turn || 0) >= maxT);
}

function calcTotals() {
  const maxT = (worldSettings && worldSettings.maxTurns) || 10;
  const turnsPlayed = Math.min((gameState.turn || 0), maxT);

  const budgetNow = Number(gameState.budget || 0);
  const budgetHist = Array.isArray(gameState.budgetHistory) ? gameState.budgetHistory : [];
  const incomeHist = Array.isArray(gameState.incomeHistory) ? gameState.incomeHistory : [];

  const totalIncome = incomeHist.reduce((a,v) => a + (Number(v)||0), 0);

  const totalTickets = Array.isArray(gameState.ticketSales) ? gameState.ticketSales : [0,0,0];
  const cap = Array.isArray(worldSettings.tickets) ? worldSettings.tickets : [0,0,0];

  const suitability = computesuitability();        // raw (not *10)
  const interest = (gameState.interest || [0,0,0]);

  const board = (gameState.board || {});
  const counts = {};
  Object.values(board).forEach(k => counts[k] = (counts[k]||0) + 1);

  const plan = (gameState.marketingPlan || {});
  const totalMktSpend = Object.values(plan).reduce((a,v) => a + (Number(v)||0), 0);

  return {
    maxT, turnsPlayed,
    budgetNow, totalIncome,
    totalTickets, cap,
    suitability, interest,
    counts,
    totalMktSpend
  };
}

function renderSummaryHtml() {
  const t = calcTotals();

  const groups = ["Group 1", "Group 2", "Group 3"];

  const ticketRows = groups.map((g,i) => {
    const sold = Number(t.totalTickets[i] || 0);
    const cap = Number(t.cap[i] || 0);
    const pct = cap > 0 ? Math.round((sold / cap) * 100) : 0;
    return `<tr><td>${g}</td><td style="text-align:right">${sold} / ${cap} (${pct}%)</td></tr>`;
  }).join("");

  const suitRows = groups.map((g,i) => {
    const s = Number(t.suitability[i] || 0);
    const it = Number(t.interest[i] || 0);
    return `<tr><td>${g}</td><td style="text-align:right">${s} / ${it}</td></tr>`;
  }).join("");

  const objKeys = Object.keys(t.counts).sort((a,b) => t.counts[b]-t.counts[a]);
  const objList = objKeys.length
    ? `<table class="summary-table">${objKeys.map(k => `<tr><td>${k}</td><td style="text-align:right">${t.counts[k]}</td></tr>`).join("")}</table>`
    : `<div class="summary-muted">No objects built.</div>`;

  return `
    <div class="summary-grid">

      <div class="summary-card">
        <h3>Outcome</h3>
        <table class="summary-table">
          <tr><td>Turns played</td><td style="text-align:right">${t.turnsPlayed} / ${t.maxT}</td></tr>
          <tr><td>Final budget</td><td style="text-align:right">â‚¬${t.budgetNow}</td></tr>
          <tr><td>Total income</td><td style="text-align:right">â‚¬${t.totalIncome}</td></tr>
          <tr><td>Total marketing spend (plan)</td><td style="text-align:right">â‚¬${t.totalMktSpend}</td></tr>
        </table>
      </div>

      <div class="summary-card">
        <h3>Ticket Sales</h3>
        <table class="summary-table">
          ${ticketRows}
        </table>
      </div>

      <div class="summary-card">
        <h3>Suitability / Interest</h3>
        <table class="summary-table">
          <tr><td class="summary-muted" colspan="2">Format: suitability / interest</td></tr>
          ${suitRows}
        </table>
      </div>

      <div class="summary-card">
        <h3>Built Objects</h3>
        ${objList}
      </div>

    </div>

    <div class="summary-muted">
      Event finished. You can restart the game to play again.
    </div>
  `;
}

function showEventSummary() {
  const overlay = document.getElementById("summary-overlay");
  const content = document.getElementById("summary-content");
  if (!overlay || !content) return;

  content.innerHTML = renderSummaryHtml();
  overlay.style.display = "flex";

  // lock gameplay buttons (optional but recommended)
  const nextBtn = document.getElementById("nextturn-btn");
  if (nextBtn) nextBtn.disabled = true;
}

function hideEventSummary() {
  const overlay = document.getElementById("summary-overlay");
  if (!overlay) return;
  overlay.style.display = "none";
}

document.getElementById("summary-close")?.addEventListener("click", hideEventSummary);

// close by clicking outside panel
document.getElementById("summary-overlay")?.addEventListener("click", (e) => {
  if (e.target && e.target.id === "summary-overlay") hideEventSummary();
});


  </script>
</body>
</html>
