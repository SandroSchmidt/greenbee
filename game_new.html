
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Green Bee â€“ Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="layout.css">
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Dein firebase.initializeApp(...) hier einfÃ¼gen -->
  <script src="functions.js"></script>
</head>

<body class="theme-light">

  <!-- HEADER -->
  <header id="main-header">
    <div class="header-left">
      <img src="logo.png" class="logo-image" alt="GreenBee Logo">
    </div>

    <div class="header-center">
      <span id="world-display" class="header-pill">World: -</span>
      <span id="player-display" class="header-pill">Player: -</span>
    </div>

    <div class="header-right">
      <!--<img src="firma-logo.png" class="company-logo" alt="Company Logo">
      <a href="impressum.html">Impressum</a>-->
      
      <button id="theme-toggle" class="btn small">â˜€ï¸Ž / ðŸŒ™</button>
    </div>
  </header>


  <!-- OVERLAY: WORLD + STUDENT SELECTION -->
  <div id="select-overlay">
    <div class="overlay-panel">
      <h2>Select World / Student</h2>

      <div class="field">
        <span>World</span>
        <select id="sel-world"></select>
      </div>

      <div class="field">
        <span>Student</span>
        <select id="sel-student"></select>
      </div>

      <button id="btn-confirm-student" class="btn primary">Continue</button>
      <p id="select-error" class="status"></p>
    </div>
  </div>


  <!-- OVERLAY: BUY / SELL -->
  <div id="buy-overlay">
    <div class="overlay-panel">
      <h2 id="buy-title">Field</h2>
      <div id="buy-content"></div>
      <button id="buy-close" class="btn small">Close</button>
    </div>
  </div>


  <!-- MAIN CONTENT -->
  <main class="page-wrap">

    <!-- OBERZEILE â€“ 70% -->
    <div class="row-grid">

      <!-- LEFT: Info Panel -->
      <section class="panel" id="panel-info">
        <h2>Marketing</h2>
        <div><strong>Budget:</strong> â‚¬<span id="info-budget">0</span></div>
        <div><strong>Income next turn:</strong> â‚¬<span id="info-income">0</span></div>

        <div style="margin-top:10px;">
          <div class="group-row"><span>Group 1 interest:</span> <span id="info-int-0">0</span></div>
          <div class="group-row"><span>Group 2 interest:</span> <span id="info-int-1">0</span></div>
          <div class="group-row"><span>Group 3 interest:</span> <span id="info-int-2">0</span></div>
        </div>
      </section>

      <!-- CENTER: SPIELFELD -->
      <section class="panel" id="panel-board">
        <svg id="game-board"></svg>
      </section>

      <!-- RIGHT: SHOP PANEL -->
      <section class="panel" id="panel-shop">
        <h2 id="turn-display">Info</h2>
        <div id="shop-container"></div>
      </section>

    </div>


    <!-- UNTERE ZEILE â€“ 30% -->
    <div class="container-bottom">

      <section class="panel" id="panel-interest">
        <h2>Interest</h2>
        <svg id="interest-chart"></svg>
      </section>

      <section class="panel" id="panel-budget">
        <h2>Budget History</h2>
        <svg id="budget-chart"></svg>
      </section>

      <section class="panel" id="panel-tickets">
        <h2>Ticket Sales</h2>
        <svg id="ticket-chart"></svg>
      </section>

    </div>

  </main>


  <!-- FOOTER -->
  <footer id="main-footer">
    <button id="restart-btn" class="btn">Restart</button>
    <button id="nextturn-btn" class="btn primary">Next Turn</button>
  </footer>

  <script>
    // ===== Theme =====
    function applyThemeFromStorage() {
      const pref = localStorage.getItem("gb-theme") || "light";
      document.body.classList.toggle("theme-dark", pref === "dark");
    }
    document.getElementById("theme-toggle").addEventListener("click", () => {
      const isDark = document.body.classList.toggle("theme-dark");
      localStorage.setItem("gb-theme", isDark ? "dark" : "light");
    });
    applyThemeFromStorage();

    // ===== URL-Parameter =====
    function getUrlParams() {
      const p = new URLSearchParams(window.location.search);
      return {
        world: p.get("world") || "",
        player: p.get("player") || ""
      };
    }

const DEFAULT_DESCRIPTIONS = {
  bank: "A simple bench where visitors can rest. Seniors appreciate comfortable seating, and families value places to pause with children.",
  
  stand: "A basic information or sales stand. Attracts visitors moderately and provides a point of interaction or small purchases.",
  
  premium: "A high-quality stand offering better products or services. Strongly increases visitor interest, especially for young people and families.",
  
  bar: "A drinks bar that provides refreshments and social atmosphere. Youth and adults find it attractive; families benefit moderately.",
  
  animals: "A virtual-reality attraction offering an immersive experience. Very appealing to young visitors and tech-interested guests.",
  
  playground: "A playground area designed for children. Greatly increases interest for families and provides activity space.",
  
  stage: "A performance stage for music, shows or entertainment. Strongly increases interest, especially among young visitors.",
  
  empty: "Empty tile. You can build something here to make the area more attractive."
};

    const GROUP_COLORS = ["#22c55e", "#3b82f6", "#f97316"];
    //layout
const CHART_MARGIN = { top: 20, right: 20, bottom: 20, left: 32 };

const CHART_X_MIN = 0;
const CHART_X_MAX = 12;

const FONT_SIZE = "10px";
const FONT_FAMILY = "system-ui, sans-serif";

    // ===== Spielzustand =====
    let globalSettings = null;
    let worldSettings = null;
    let worldId = "";
    let playerId = "";
    let studentRecord = null;

    let gameState = null;
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

 function createEmptyGameState() {
  const startBudget = worldSettings.startBudget || 0;
  return {
    turn: 0,
    budget: startBudget,
    board: {},                 // { "A1":"shop", ... }
    budgetHistory: [startBudget],
    incomeHistory: [0],        // Einkommen pro Turn
    ticketSales: [0,0,0]       // drei Gruppen
  };
}


    function computeIncome() {
      const objs = globalSettings.objects || {};
      let income = 0;
      Object.values(gameState.board || {}).forEach(key => {
        const o = objs[key];
        if (o && o.income) income += o.income;
      });
      return income;
    }

    function computeInterest() {
      const objs = globalSettings.objects || {};
      const res = [0,0,0];
      Object.values(gameState.board || {}).forEach(key => {
        const o = objs[key];
        if (!o || !Array.isArray(o.interest)) return;
        o.interest.forEach((v,i) => {
          res[i] += (v||0);
        });
      });
      return res;
    }

    function calculateTicketsAfterTurn(interestVec) {
      const totalAvailable = worldSettings.tickets || [0,0,0];
      const sold = gameState.ticketSales || [0,0,0];
      const remaining = totalAvailable.map((t,i) => Math.max(0, t - (sold[i]||0)));

      // einfache lineare Logik: Anteil interest / (interest + 50) * (remaining / (restliche Runden))
      const k = (globalSettings.baseRules && globalSettings.baseRules.interestSaturationK) || 50;
      const turnsLeft = Math.max(1, (worldSettings.maxTurns || 10) - gameState.turn);
      const newSales = [0,0,0];

      interestVec.forEach((ival, i) => {
        if (remaining[i] <= 0) return;
        const factor = ival <= 0 ? 0 : (ival / (ival + k));
        const base = remaining[i] / turnsLeft;
        const tickets = Math.min(remaining[i], Math.round(base * factor));
        newSales[i] = tickets;
      });

      gameState.ticketSales = sold.map((oldVal, i) => oldVal + (newSales[i] || 0));
    }

    // ===== UI Updates =====

    function updateInfoPanel() {
      const interest = computeInterest();
      const income = computeIncome();

      document.getElementById("info-budget").textContent = gameState.budget;
      document.getElementById("info-income").textContent = income;
      document.getElementById("info-int-0").textContent = interest[0] || 0;
      document.getElementById("info-int-1").textContent = interest[1] || 0;
      document.getElementById("info-int-2").textContent = interest[2] || 0;
      document.getElementById("turn-display").textContent = "Turn " + (gameState.turn || 0);
    }

function renderBoard() {
  const svg = d3.select("#game-board");
  svg.selectAll("*").remove();

  // Panel-MaÃŸe dynamisch bestimmen
  const panel = document.getElementById("panel-board");
  let width = panel.clientWidth;
  let height = panel.clientHeight;

  // Fallback, falls noch 0 (z.B. beim allerersten Render)
  if (!width || !height) {
    width = 600;
    height = 420;
  }

  // SVG so aufziehen, dass es mit diesen MaÃŸen arbeitet
  svg.attr("viewBox", `0 0 ${width} ${height}`);

  const gridSize = worldSettings.gridSize || 5;
  const objs = globalSettings.objects || {};
  const board = (gameState && gameState.board) ? gameState.board : {};
  const hexW = width / (gridSize );
  const hexH = hexW * 0.5;

  // Erst alle Zellen in "rohen" Koordinaten sammeln, dann zentrieren
  const cells = [];
  for (let row = 1; row <= gridSize; row++) {
    for (let col = gridSize - 1; col >= 0; col--) {
      const id = letters[col] + row;

      // Iso-Koordinaten relativ zu (0,0)
      const cx = (hexW * (0.5 * (col + row)));
      const cy = -(hexH * (0.5 * (col - row)));

      cells.push({ id, cx, cy });
    }
  }

  // Bounding Box der Zellen berechnen
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  cells.forEach(c => {
    if (c.cx < minX) minX = c.cx;
    if (c.cx > maxX) maxX = c.cx;
    if (c.cy < minY) minY = c.cy;
    if (c.cy > maxY) maxY = c.cy;
  });

  // Verschiebung, damit alles im Panel zentriert ist
  const centerGridX = (minX + maxX) / 2;
  const centerGridY = (minY + maxY) / 2;
  const offsetX = width / 2 - centerGridX;
  const offsetY = height / 2 - centerGridY;

  // Jetzt wirklich zeichnen
  cells.forEach(c => {
    const id = c.id;
    const cx = c.cx + offsetX;
    const cy = c.cy + offsetY;

    const objKey = board[id];
    const obj = objs[objKey] || {};
    const color = obj.color || "#9ca3af";

    const points = [
      [cx - hexW * 0.5, cy],
      [cx, cy + hexH * 0.5],
      [cx + hexW * 0.5, cy],
      [cx, cy - hexH * 0.5]
    ];

    const g = svg.append("g").attr("data-id", id);

    g.append("polygon")
      .attr("points", points.map(p => p.join(",")).join(" "))
      .attr("fill", color)
      .attr("stroke", "#111827")
      .attr("stroke-width", 1)
      .on("click", () => onCellClicked(id))

    if (obj.icon) {
      g.append("image")
        .attr("href", obj.icon)
        .attr("x", cx - hexW * 0.8)
        .attr("y", cy - hexH * 1.4)
        .attr("width", hexW * 1.6)
        .attr("height", hexH * 2.2)
        .on("mouseover", () => showTileInfo(id))
  .on("mouseout", () => clearTileInfo())

        .style("pointer-events", "none");
    }
  });
}

    function renderShop(selectedId, hasObject) {
  const overlayEl = document.getElementById("buy-overlay");
  const content = d3.select("#buy-content");
  const title = d3.select("#buy-title");
  const shopInfo = d3.select("#shop-container");

  content.html("");
  shopInfo.html("");

  // Kein Feld ausgewÃ¤hlt -> Overlay aus, Hinweis im rechten Panel
  if (!selectedId) {
    overlayEl.style.display = "none";
    shopInfo.append("div").text("Click on a tile to build.");
    return;
  }

  // Header-Texte
  title.text("Field " + selectedId);
  shopInfo.append("div").text("Selected: " + selectedId);

  // Overlay anzeigen
  overlayEl.style.display = "flex";

  // Bereits bebautes Feld -> Sell-Option
  if (hasObject) {
    const objKey = gameState.board[selectedId];
    const obj = (globalSettings.objects || {})[objKey] || {};
    const sellPrice = Math.round((obj.price || 0) / 2);

    content.append("p").text(`You built: ${objKey}`);
    content.append("p").text(`Sell for â‚¬${sellPrice}?`);

    content.append("button")
      .attr("class", "btn primary small")
      .style("margin-top", "6px")
      .text(`Sell ${objKey}`)
      .on("click", async () => {
        gameState.budget += sellPrice;
        delete gameState.board[selectedId];
        gameState.budgetHistory[gameState.turn] = gameState.budget;

        overlayEl.style.display = "none";
        renderBoard();
        renderShop(null, false);
        updateAll();
        await saveGameState(worldId, playerId, gameState);
      });

  } else {
    // Leeres Feld -> Buy-Liste
    content.append("p").text("Choose an object to build:");

    const objs = globalSettings.objects || {};
    const enabled = worldSettings.objectsEnabled || {};

    Object.keys(objs).forEach(key => {
      if (!enabled[key]) return; // in dieser World deaktiviert

      const o = objs[key];

      content.append("button")
        .attr("class", "btn small")
        .style("margin", "4px 4px 0 0")
        .text(`${key} (â‚¬${o.price || 0})`)
        .on("click", async () => {
          const cost = o.price || 0;
          if (gameState.budget < cost) {
            alert("Not enough budget.");
            return;
          }

          gameState.budget -= cost;
          gameState.board[selectedId] = key;
          gameState.budgetHistory[gameState.turn] = gameState.budget;

          overlayEl.style.display = "none";
          renderBoard();
          renderShop(null, false);
          updateAll();
          await saveGameState(worldId, playerId, gameState);
        });
    });
  }
}

function onCellClicked(id) {
  const hasObject = !!gameState.board[id];
  renderShop(id, hasObject);
}

function renderInterestChart() {
  const svg = d3.select("#interest-chart");
  svg.selectAll("*").remove();

  const { width, height } = setupDynamicSvg(svg);

  const interest = computeInterest();
  const data = [
    { group: "Youth",    value: interest[0] || 0, color: GROUP_COLORS[0] },
    { group: "Families", value: interest[1] || 0, color: GROUP_COLORS[1] },
    { group: "Seniors",  value: interest[2] || 0, color: GROUP_COLORS[2] }
  ];

  const maxY = Math.max(1, d3.max(data, d => d.value));

  const x = d3.scaleBand()
    .domain(data.map(d => d.group))
    .range([CHART_MARGIN.left, width - CHART_MARGIN.right])
    .padding(0.3);

  const y = d3.scaleLinear()
    .domain([0, maxY])
    .range([height - CHART_MARGIN.bottom, CHART_MARGIN.top]);

  const axX = svg.append("g")
    .attr("transform", `translate(0,${height - CHART_MARGIN.bottom})`)
    .call(d3.axisBottom(x));

  const axY = svg.append("g")
    .attr("transform", `translate(${CHART_MARGIN.left},0)`)
    .call(d3.axisLeft(y).ticks(4));

  axX.selectAll("text")
    .style("font-size", FONT_SIZE)
    .style("font-family", FONT_FAMILY);

  axY.selectAll("text")
    .style("font-size", FONT_SIZE)
    .style("font-family", FONT_FAMILY);

  svg.selectAll("rect")
    .data(data)
    .enter()
    .append("rect")
    .attr("x", d => x(d.group))
    .attr("y", d => y(d.value))
    .attr("height", d => y(0) - y(d.value))
    .attr("width", x.bandwidth())
    .attr("fill", d => d.color);
}

function renderBudgetChart() {
  const svg = d3.select("#budget-chart");
  svg.selectAll("*").remove();

  const { width, height } = setupDynamicSvg(svg);

  // Budget-Verlauf
  const history = (gameState.budgetHistory || []).map((v, i) => ({
    turn: i,
    value: v
  }));

  // Einkommen pro Turn aus gameState.incomeHistory nehmen
  const rawIncome = gameState.incomeHistory || [];
  const incomeHistory = history.map((d, i) => ({
    turn: i,
    value: rawIncome[i] || 0
  }));

  const turnNow = gameState.turn || 0;

  const maxY = Math.max(
    1,
    d3.max(history, d => d.value),
    d3.max(incomeHistory, d => d.value)
  );

  const x = d3.scaleLinear()
    .domain([CHART_X_MIN, CHART_X_MAX])
    .range([CHART_MARGIN.left, width - CHART_MARGIN.right]);

  const y = d3.scaleLinear()
    .domain([0, maxY])
    .range([height - CHART_MARGIN.bottom, CHART_MARGIN.top]);

  const ticks = d3.range(CHART_X_MIN, CHART_X_MAX + 1);

  // â€¦ ab hier kann dein bisheriger Achsen- und Liniencode unverÃ¤ndert bleiben â€¦


  // Achsen
  svg.append("g")
    .attr("transform", `translate(0,${height - CHART_MARGIN.bottom})`)
    .call(d3.axisBottom(x).tickValues(ticks).tickFormat(d => "T" + d))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  svg.append("g")
    .attr("transform", `translate(${CHART_MARGIN.left},0)`)
    .call(d3.axisLeft(y).ticks(4))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  // Liniengenerator
  const line = d3.line()
    .x(d => x(d.turn))
    .y(d => y(d.value));

  // GRÃœNE LINIE: Budget
  svg.append("path")
    .datum(history)
    .attr("fill", "none")
    .attr("stroke", "#22c55e")
    .attr("stroke-width", 2)
    .attr("d", line);

  // BLAUE LINIE: Einnahmen pro Runde
  svg.append("path")
    .datum(incomeHistory)
    .attr("fill", "none")
    .attr("stroke", "#3b82f6")
    .attr("stroke-width", 2)
 //   .attr("stroke-dasharray", "4 2")
    .attr("d", line);

  // ROTE TURN-LINIE
  svg.append("line")
    .attr("x1", x(turnNow))
    .attr("x2", x(turnNow))
    .attr("y1", CHART_MARGIN.top)
    .attr("y2", height - CHART_MARGIN.bottom)
    .attr("stroke", "red")
    .attr("stroke-width", 2);
}

function renderTicketChart() {
  const svg = d3.select("#ticket-chart");
  svg.selectAll("*").remove();

  const { width, height } = setupDynamicSvg(svg);

  const totalAvailable = worldSettings.tickets || [0,0,0];
  const soldNow = gameState.ticketSales || [0,0,0];
  const interest = computeInterest();
  const k = (globalSettings.baseRules?.interestSaturationK) || 50;
  const turnNow = gameState.turn || 0;

  function simulateStep(current) {
    return current.map((v, i) => {
      const rem = totalAvailable[i] - v;
      if (rem <= 0) return v;
      const factor = interest[i] / (interest[i] + k);
      return v + Math.min(rem, Math.round(rem * factor * 0.25));
    });
  }

  const series = [];
  let sold = soldNow.slice();
  series.push({ t: turnNow, g0: sold[0], g1: sold[1], g2: sold[2] });

  for (let i = 1; i <= 3; i++) {
    sold = simulateStep(sold);
    series.push({ t: turnNow + i, g0: sold[0], g1: sold[1], g2: sold[2] });
  }

  const x = d3.scaleLinear()
    .domain([CHART_X_MIN, CHART_X_MAX])
    .range([CHART_MARGIN.left, width - CHART_MARGIN.right]);

  const maxY = d3.max(series, d => d.g0 + d.g1 + d.g2) || 1;

  const y = d3.scaleLinear()
    .domain([0, maxY])
    .range([height - CHART_MARGIN.bottom, CHART_MARGIN.top]);

  const stack = d3.stack().keys(["g0", "g1", "g2"]);
  const stacked = stack(series);

  const area = d3.area()
    .x(d => x(d.data.t))
    .y0(d => y(d[0]))
    .y1(d => y(d[1]));

  const colors = ["#22c55e", "#3b82f6", "#f97316"];

  stacked.forEach((layer, i) => {
    svg.append("path")
      .datum(layer)
      .attr("fill", colors[i])
      .attr("fill-opacity", 0.6)
      .attr("d", area);
  });

  const ticks = d3.range(CHART_X_MIN, CHART_X_MAX + 1);

  svg.append("g")
    .attr("transform", `translate(0,${height - CHART_MARGIN.bottom})`)
    .call(d3.axisBottom(x).tickValues(ticks).tickFormat(d => "T" + d))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  svg.append("g")
    .attr("transform", `translate(${CHART_MARGIN.left},0)`)
    .call(d3.axisLeft(y).ticks(4))
    .selectAll("text").style("font-size", FONT_SIZE).style("font-family", FONT_FAMILY);

  svg.append("line")
    .attr("x1", x(turnNow))
    .attr("x2", x(turnNow))
    .attr("y1", CHART_MARGIN.top)
    .attr("y2", height - CHART_MARGIN.bottom)
    .attr("stroke", "red")
    .attr("stroke-width", 2);
}

function updateAll() {
  updateInfoPanel();
  renderInterestChart();
  renderBudgetChart();
  renderTicketChart();
}



    document.getElementById("buy-close").addEventListener("click", () => {
  document.getElementById("buy-overlay").style.display = "none";
  d3.select("#shop-container").html("");
});
    // ===== Turn-Logik =====

  async function nextTurn() {
  const income = computeIncome();

  // Turn hochzÃ¤hlen
  gameState.turn = (gameState.turn || 0) + 1;

  // Budget aktualisieren
  gameState.budget = (gameState.budget || 0) + income;

  // History-Arrays pflegen
  if (!Array.isArray(gameState.budgetHistory)) gameState.budgetHistory = [];
  if (!Array.isArray(gameState.incomeHistory)) gameState.incomeHistory = [];

  gameState.budgetHistory[gameState.turn] = gameState.budget;
  gameState.incomeHistory[gameState.turn] = income;

  const interest = computeInterest();
  calculateTicketsAfterTurn(interest);

  updateAll();
  await saveGameState(worldId, playerId, gameState);
}

    async function restartGame() {
      if (!confirm("Restart game? This will reset your board.")) return;
      gameState = createEmptyGameState();
      renderBoard();
      renderShop(null,false);
      updateAll();
      await saveGameState(worldId, playerId, gameState);
    }

    document.getElementById("nextturn-btn").addEventListener("click", () => {
      nextTurn();
    });
    document.getElementById("restart-btn").addEventListener("click", () => {
      restartGame();
    });

    // ===== Auswahl-Overlay =====

    async function showSelectionOverlay() {
      const overlay = document.getElementById("select-overlay");
      overlay.style.display = "flex";

      const worlds = await listWorlds();
      const selWorld = document.getElementById("sel-world");
      selWorld.innerHTML = "";
      worlds.forEach(w => {
        const opt = document.createElement("option");
        opt.value = w;
        opt.textContent = w;
        selWorld.appendChild(opt);
      });

      async function fillStudents() {
        const w = selWorld.value;
        const ws = await loadWorldSettings(w);
        const students = ws.students || {};
        const selStudent = document.getElementById("sel-student");
        selStudent.innerHTML = "";
        Object.keys(students).forEach(id => {
          const opt = document.createElement("option");
          opt.value = id;
          opt.textContent = students[id].name || id;
          selStudent.appendChild(opt);
        });
      }

      selWorld.addEventListener("change", fillStudents);
      await fillStudents();

      document.getElementById("btn-confirm-student").onclick = async () => {
        const w = selWorld.value;
        const s = document.getElementById("sel-student").value;
        const ws = await loadWorldSettings(w);
        const students = ws.students || {};
        const rec = students[s];
        if (!rec) {
          document.getElementById("select-error").textContent = "Student not found.";
          return;
        }
        const code = prompt("Enter your code:");
        if (code !== rec.code) {
          document.getElementById("select-error").textContent = "Wrong code.";
          return;
        }
        worldId = w;
        playerId = s;
        studentRecord = rec;
        overlay.style.display = "none";
        startGame();
      };
    }

    // ===== Start =====

    async function startGame() {
      document.getElementById("world-display").textContent = "World: " + worldId;
      document.getElementById("player-display").textContent = "Player: " + (studentRecord && studentRecord.name || playerId);

      globalSettings = await loadGlobalSettings();
      worldSettings = await loadWorldSettings(worldId);

    let existing = await loadGameState(worldId, playerId);
if (!existing) {
  existing = createEmptyGameState();
  await saveGameState(worldId, playerId, existing);
}
gameState = existing;

// alte SpielstÃ¤nde reparieren, falls Felder fehlen
if (!gameState.board) {
  gameState.board = {};
}
if (!Array.isArray(gameState.budgetHistory)) {
  gameState.budgetHistory = [gameState.budget || 0];
}
if (!Array.isArray(gameState.ticketSales)) {
  gameState.ticketSales = [0, 0, 0];
}
if (!Array.isArray(gameState.incomeHistory)) {
  gameState.incomeHistory = [];
}

// aktuelles Einkommen fÃ¼r aktuellen Turn eintragen
const currentTurn = gameState.turn || 0;
const currentIncome = computeIncome();
gameState.incomeHistory[currentTurn] = currentIncome;



      renderBoard();
      renderShop(null,false);
      updateAll();
    }

    (async function init() {
      const params = getUrlParams();
      if (params.world && params.player) {
        // Direkt aus URL, trotzdem Code checken
        worldId = params.world;
        playerId = params.player;
        const ws = await loadWorldSettings(worldId);
        const students = ws.students || {};
        const rec = students[playerId];
        if (!rec) {
          await showSelectionOverlay();
        } else {
          const code = prompt("Enter your code:");
          if (code !== rec.code) {
            await showSelectionOverlay();
            return;
          }
          studentRecord = rec;
          await startGame();
        }
      } else {
        await showSelectionOverlay();
      }
    })();
// ===== Fenster-Resize ===== -> board rezise
    window.addEventListener("resize", () => {
  if (gameState) renderBoard();
});


function setupDynamicSvg(svg) {
  const node = svg.node();
  const parent = node.parentElement;

  const w = parent.clientWidth;
  const h = parent.clientHeight;

  // Falls beim ersten Render 0x0 â†’ Notfallwerte
  const width = Math.max(w, 200);
  const height = Math.max(h, 120);

  svg.attr("viewBox", `0 0 ${width} ${height}`);

  return { width, height };
}
function showTileInfo(id) {
  console.log(id)

  const hoverEl = document.getElementById("shop-hover-info");
  if (!hoverEl) return;

  const board = (gameState && gameState.board) ? gameState.board : {};
  const objs = globalSettings.objects || {};
  const objKey = board[id];

  // Wenn etwas auf dem Feld steht
  if (objKey && objs[objKey]) {
    const o = objs[objKey];
    const desc =
      o.descriptionEn ||
      DEFAULT_DESCRIPTIONS[objKey] ||
      "This object has no description yet.";

    const priceText =
      (o.price !== undefined && o.price !== null)
        ? `Cost: â‚¬${o.price}. `
        : "";

    const incomeText =
      (o.income !== undefined && o.income !== null && o.income !== 0)
        ? `Income per turn: â‚¬${o.income}. `
        : "";

    hoverEl.textContent = `Tile ${id}: ${objKey}. ${desc} ${priceText}${incomeText}`;
  } else {
    // Leeres Feld
    const descEmpty =
      DEFAULT_DESCRIPTIONS.empty ||
      "Empty tile. You can build something here.";
    hoverEl.textContent = `Tile ${id} is empty. ${descEmpty}`;
  }
}

function clearTileInfo() {
  const hoverEl = document.getElementById("shop-hover-info");
  if (!hoverEl) return;
  hoverEl.textContent = "Hover over a tile to see details.";
}

  </script>
</body>
</html>
